
-------------------------- numpy count occurences of element in array --------------------------

np.count_nonzero(table == '0')




-------------------------- shallow / deep copy --------------------------

Making a shallow copy of an object won’t clone child objects.
Therefore, the copy is not fully independent of the original.
A deep copy of an object will recursively clone child objects.
 The clone is fully independent of the original, but creating a deep copy is slower.
 
 

-------------------------- underscores --------------------------

__double_leading_underscore : __foo replaced by the interpreter by  _classname__foo so that it does not overlap

_single_leading_underscore : _internal_name : private variable : ignored in "from xxx import *",
unless specified in __all__



-------------------------- multiple inheritance --------------------------

multiple inheritance : copy of the first method found
class C(B,A): __init__ from B is copied, not from A.
super() returns the 1st method of the first parent (or grandparent) found



-------------------------- instances --------------------------

instance.value : looked for in : 1-instance, 2-subclass, 3-superclass, 4-object

keep track of instances:
class A:
    instances = []
    def __init__(self, foo):
        self.foo = foo
        A.instances.append(self)

At the end of the program :
foo_vars = {id(instance):instance.foo for instance in A.instances}




-------------------------- hashable object --------------------------

hashable object : value that does not change, must have the method __hash__()




-------------------------- imports --------------------------

"clean" import
1 - create a wrapper module separated from the code:
import sys
import os
sys.path.insert(0, os.path.join(...,lib))
import mylib
del sys.path[0]

2 -
from lib import mylib




-------------------------- force reinstall --------------------------

reinstall package when it really does not work!
pip install --user --force-reinstall --ignore-installed --no-binary :all: package name





-------------------------- concepts --------------------------

LBYL: look before you leap : if key in dic ....
EAFP : easier to ask for forgiveness than permission : try: .... except: ....




-------------------------- imports / packages --------------------------

import mod
mod.__file__
> 'C:\\users\\mat\\mod.py'

python >=3.3 : __init__.py not necessary to make a package




-------------------------- pytest --------------------------

pytest: assert an error is raised:
with pytest.raises(ValueError):
    fibonacci(-1)





    
-------------------------- mutual imports --------------------------

Mutual top-level imports: from SO

If you do import foo inside bar and import bar inside foo, it will work fine. 
By the time anything actually runs, both modules will be fully loaded and will have references to each other.

The problem is when instead you do from foo import abc and from bar import xyz. 
Because now each module requires the other module to already be imported 
(so that the name we are importing exists) before it can be imported.





-------------------------- sequence --------------------------

Why is “1000000000000000 in range(1000000000000001)” so fast in Python 3?  from SO

The Python 3 range() object doesn't produce numbers immediately; 
it is a smart sequence object that produces numbers on demand.
The object also implements the object.__contains__ hook, and calculates if your number is part of its range. 

For example, 994 is in range(4, 1000, 2) because:
    4 <= 994 < 1000, and
    (994 - 4) % 2 == 0.


range is not a generator:
>>> a = range(5)
>>> print(list(a))
[0, 1, 2, 3, 4]
>>> print(list(a))
[0, 1, 2, 3, 4]

range actually is a sequence, just like a list:
>>> import collections.abc
>>> isinstance(a, collections.abc.Sequence)
True




-------------------------- default values parameters --------------------------

For functions:

In [7]: def f(l=[1,2,3]):
   ...:     l.append(4)
   ...:     return l
   ...:

In [8]: f()
Out[8]: [1, 2, 3, 4]

In [9]: f([5,5])
Out[9]: [5, 5, 4]

In [10]: f()
Out[10]: [1, 2, 3, 4, 4]


For class variables:

class A:
    v = ['c', 'p']
 
>>> g1 = A()
>>> g2 = A()
>>> g1.v.pop()
'p'
>>> g2.v
['c']


--------------------------  --------------------------


--------------------------  --------------------------


--------------------------  --------------------------


--------------------------  --------------------------










